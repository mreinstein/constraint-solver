'use strict';

var kiwi = require('kiwi.js');

/*
 * Generated by PEG.js 0.10.0.
 *
 * http://pegjs.org/
 */

function peg$subclass(child, parent) {
  function ctor() {
    this.constructor = child;
  }

  ctor.prototype = parent.prototype;
  child.prototype = new ctor();
}

function peg$SyntaxError(message, expected, found, location) {
  this.message = message;
  this.expected = expected;
  this.found = found;
  this.location = location;
  this.name = "SyntaxError";

  if (typeof Error.captureStackTrace === "function") {
    Error.captureStackTrace(this, peg$SyntaxError);
  }
}

peg$subclass(peg$SyntaxError, Error);

peg$SyntaxError.buildMessage = function (expected, found) {
  var DESCRIBE_EXPECTATION_FNS = {
    literal: function literal(expectation) {
      return "\"" + literalEscape(expectation.text) + "\"";
    },
    "class": function _class(expectation) {
      var escapedParts = "",
          i;

      for (i = 0; i < expectation.parts.length; i++) {
        escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
      }

      return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
    },
    any: function any(expectation) {
      return "any character";
    },
    end: function end(expectation) {
      return "end of input";
    },
    other: function other(expectation) {
      return expectation.description;
    }
  };

  function hex(ch) {
    return ch.charCodeAt(0).toString(16).toUpperCase();
  }

  function literalEscape(s) {
    return s.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
      return '\\x0' + hex(ch);
    }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
      return '\\x' + hex(ch);
    });
  }

  function classEscape(s) {
    return s.replace(/\\/g, '\\\\').replace(/\]/g, '\\]').replace(/\^/g, '\\^').replace(/-/g, '\\-').replace(/\0/g, '\\0').replace(/\t/g, '\\t').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/[\x00-\x0F]/g, function (ch) {
      return '\\x0' + hex(ch);
    }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) {
      return '\\x' + hex(ch);
    });
  }

  function describeExpectation(expectation) {
    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
  }

  function describeExpected(expected) {
    var descriptions = new Array(expected.length),
        i,
        j;

    for (i = 0; i < expected.length; i++) {
      descriptions[i] = describeExpectation(expected[i]);
    }

    descriptions.sort();

    if (descriptions.length > 0) {
      for (i = 1, j = 1; i < descriptions.length; i++) {
        if (descriptions[i - 1] !== descriptions[i]) {
          descriptions[j] = descriptions[i];
          j++;
        }
      }

      descriptions.length = j;
    }

    switch (descriptions.length) {
      case 1:
        return descriptions[0];

      case 2:
        return descriptions[0] + " or " + descriptions[1];

      default:
        return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
    }
  }

  function describeFound(found) {
    return found ? "\"" + literalEscape(found) + "\"" : "end of input";
  }

  return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
};

function peg$parse(input, options) {
  options = options !== void 0 ? options : {};
  var peg$FAILED = {},
      peg$startRuleIndices = {
    start: 0
  },
      peg$startRuleIndex = 0,
      peg$consts = [function (statements) {
    return statements;
  }, function (expression, strength) {
    var s = strength.length ? strength[0].toUpperCase() : 'STRONG';
    expression.strength = s;
    return expression;
  }, function (name) {
    var s = typeof strength !== 'undefined' ? strength.toUpperCase() : 'STRONG';
    return {
      type: "EditableVariable",
      name: name,
      strength: s
    };
  }, peg$anyExpectation(), /^[a-zA-Z.]/, peg$classExpectation([["a", "z"], ["A", "Z"], "."], false, false), "$", peg$literalExpectation("$", false), "_", peg$literalExpectation("_", false), /^[0-9]/, peg$classExpectation([["0", "9"]], false, false), peg$otherExpectation("whitespace"), /^[\t\x0B\f \xA0\uFEFF]/, peg$classExpectation(["\t", "\x0B", "\f", " ", "\xA0", "\uFEFF"], false, false), /^[\n\r\u2028\u2029]/, peg$classExpectation(["\n", "\r", "\u2028", "\u2029"], false, false), peg$otherExpectation("end of line"), "\n", peg$literalExpectation("\n", false), "\r\n", peg$literalExpectation("\r\n", false), "\r", peg$literalExpectation("\r", false), "\u2028", peg$literalExpectation("\u2028", false), "\u2029", peg$literalExpectation("\u2029", false), ";", peg$literalExpectation(";", false), peg$otherExpectation("comment"), "/*", peg$literalExpectation("/*", false), "*/", peg$literalExpectation("*/", false), "//", peg$literalExpectation("//", false), function (val) {
    return {
      type: "NumericLiteral",
      value: val
    };
  }, function (digits) {
    return parseInt(digits.join(""));
  }, ".", peg$literalExpectation(".", false), function (digits) {
    return parseFloat(digits.join(""));
  }, /^[\-+]/, peg$classExpectation(["-", "+"], false, false), peg$otherExpectation("identifier"), function (name) {
    return name;
  }, function (start, parts) {
    return start + parts.join("");
  }, function (name) {
    return {
      type: "Variable",
      name: name
    };
  }, "(", peg$literalExpectation("(", false), ")", peg$literalExpectation(")", false), function (expression) {
    return expression;
  }, function (operator, expression) {
    return {
      type: "UnaryExpression",
      operator: operator,
      expression: expression
    };
  }, "+", peg$literalExpectation("+", false), "-", peg$literalExpectation("-", false), "!", peg$literalExpectation("!", false), function (head, tail) {
    var result = head;

    for (var i = 0; i < tail.length; i++) {
      result = {
        type: "MultiplicativeExpression",
        operator: tail[i][1],
        left: result,
        right: tail[i][3]
      };
    }

    return result;
  }, "*", peg$literalExpectation("*", false), "/", peg$literalExpectation("/", false), function (head, tail) {
    var result = head;

    for (var i = 0; i < tail.length; i++) {
      result = {
        type: "AdditiveExpression",
        operator: tail[i][1],
        left: result,
        right: tail[i][3]
      };
    }

    return result;
  }, function (head, tail) {
    var result = head;

    for (var i = 0; i < tail.length; i++) {
      result = {
        type: "Inequality",
        operator: tail[i][1],
        left: result,
        right: tail[i][3]
      };
    }

    return result;
  }, "<=", peg$literalExpectation("<=", false), ">=", peg$literalExpectation(">=", false), "<", peg$literalExpectation("<", false), ">", peg$literalExpectation(">", false), "editable", peg$literalExpectation("EDITABLE", true), "required", peg$literalExpectation("REQUIRED", true), "strong", peg$literalExpectation("STRONG", true), "medium", peg$literalExpectation("MEDIUM", true), "weak", peg$literalExpectation("WEAK", true), "==", peg$literalExpectation("==", false), function (head, tail) {
    var result = head;

    for (var i = 0; i < tail.length; i++) {
      result = {
        type: "Equality",
        operator: tail[i][1],
        left: result,
        right: tail[i][3]
      };
    }

    return result;
  }],
      peg$bytecode = [peg$decode("%;//A#$;!0#*;!&/1$;//($8#: #!!)(#'#(\"'#&'#"), peg$decode("%;//k#;A/b$$;%0#*;%&/R$$;@0#*;@&/B$$;%0#*;%&/2$;(/)$8&:!&\"$\")(&'#(%'#($'#(#'#(\"'#&'#.\xA1 &%;//\x97#;?/\x8E$$;%/&#0#*;%&&&#/x$;4/o$%$;%/&#0#*;%&&&#/,#;@/#$+\")(\"'#&'#.\" &\"/A$$;%0#*;%&/1$;(/($8':\"'!#)(''#(&'#(%'#($'#(#'#(\"'#&'#"), peg$decode("1\"\"5!7#"), peg$decode("4$\"\"5!7%.5 &2&\"\"6&7'.) &2(\"\"6(7)"), peg$decode(";#.) &4*\"\"5!7+"), peg$decode("<4-\"\"5!7.=.\" 7,"), peg$decode("4/\"\"5!70"), peg$decode("<22\"\"6273.M &24\"\"6475.A &26\"\"6677.5 &28\"\"6879.) &2:\"\"6:7;=.\" 71"), peg$decode("%;//2#2<\"\"6<7=/#$+\")(\"'#&'#.O &%;./,#;'/#$+\")(\"'#&'#.6 &%;//,#;)/#$+\")(\"'#&'#"), peg$decode("%<1\"\"5!7#=.##&&!&'#"), peg$decode("<;+.# &;-=.\" 7>"), peg$decode("%2?\"\"6?7@/\x8C#$%%<2A\"\"6A7B=.##&&!&'#/,#;\"/#$+\")(\"'#&'#0H*%%<2A\"\"6A7B=.##&&!&'#/,#;\"/#$+\")(\"'#&'#&/2$2A\"\"6A7B/#$+#)(#'#(\"'#&'#"), peg$decode("%2?\"\"6?7@/\x98#$%%<2A\"\"6A7B.# &;&=.##&&!&'#/,#;\"/#$+\")(\"'#&'#0N*%%<2A\"\"6A7B.# &;&=.##&&!&'#/,#;\"/#$+\")(\"'#&'#&/2$2A\"\"6A7B/#$+#)(#'#(\"'#&'#"), peg$decode("%2C\"\"6C7D/\x80#$%%<;&=.##&&!&'#/,#;\"/#$+\")(\"'#&'#0B*%%<;&=.##&&!&'#/,#;\"/#$+\")(\"'#&'#&/2$;&.# &;)/#$+#)(#'#(\"'#&'#"), peg$decode("$;%.) &;,.# &;-0/*;%.) &;,.# &;-&"), peg$decode("$;%.) &;'.# &;*0/*;%.) &;'.# &;*&"), peg$decode("%;2.# &;1/' 8!:E!! )"), peg$decode("%$4*\"\"5!7+/,#0)*4*\"\"5!7+&&&#/' 8!:F!! )"), peg$decode("%%;1/;#2G\"\"6G7H/,$;1/#$+#)(#'#(\"'#&'#/' 8!:I!! )"), peg$decode("%4J\"\"5!7K.\" &\"/E#$4*\"\"5!7+/,#0)*4*\"\"5!7+&&&#/#$+\")(\"'#&'#"), peg$decode("<%;5/' 8!:M!! )=.\" 7L"), peg$decode("<%;#/9#$;$0#*;$&/)$8\":N\"\"! )(\"'#&'#=.\" 7L"), peg$decode("%;4/' 8!:O!! ).h &;0.b &%2P\"\"6P7Q/R#;//I$;A/@$;//7$2R\"\"6R7S/($8%:T%!\")(%'#($'#(#'#(\"'#&'#"), peg$decode(";6.E &%;8/;#;//2$;7/)$8#:U#\"\" )(#'#(\"'#&'#"), peg$decode("2V\"\"6V7W.5 &2X\"\"6X7Y.) &2Z\"\"6Z7["), peg$decode("%;7/\x83#$%;//>#;:/5$;//,$;7/#$+$)($'#(#'#(\"'#&'#0H*%;//>#;:/5$;//,$;7/#$+$)($'#(#'#(\"'#&'#&/)$8\":\\\"\"! )(\"'#&'#"), peg$decode("2]\"\"6]7^.) &2_\"\"6_7`"), peg$decode("%;9/\x83#$%;//>#;</5$;//,$;9/#$+$)($'#(#'#(\"'#&'#0H*%;//>#;</5$;//,$;9/#$+$)($'#(#'#(\"'#&'#&/)$8\":a\"\"! )(\"'#&'#"), peg$decode("2V\"\"6V7W.) &2X\"\"6X7Y"), peg$decode("%;;/\x83#$%;//>#;>/5$;//,$;;/#$+$)($'#(#'#(\"'#&'#0H*%;//>#;>/5$;//,$;;/#$+$)($'#(#'#(\"'#&'#&/)$8\":b\"\"! )(\"'#&'#"), peg$decode("2c\"\"6c7d.A &2e\"\"6e7f.5 &2g\"\"6g7h.) &2i\"\"6i7j"), peg$decode("3k\"\"5(7l"), peg$decode("3m\"\"5(7n.A &3o\"\"5&7p.5 &3q\"\"5&7r.) &3s\"\"5$7t"), peg$decode("%;=/\x8F#$%;//D#2u\"\"6u7v/5$;//,$;=/#$+$)($'#(#'#(\"'#&'#0N*%;//D#2u\"\"6u7v/5$;//,$;=/#$+$)($'#(#'#(\"'#&'#&/)$8\":w\"\"! )(\"'#&'#")],
      peg$currPos = 0,
      peg$savedPos = 0,
      peg$posDetailsCache = [{
    line: 1,
    column: 1
  }],
      peg$maxFailPos = 0,
      peg$maxFailExpected = [],
      peg$silentFails = 0,
      peg$result;

  if ("startRule" in options) {
    if (!(options.startRule in peg$startRuleIndices)) {
      throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
    }

    peg$startRuleIndex = peg$startRuleIndices[options.startRule];
  }

  function peg$literalExpectation(text, ignoreCase) {
    return {
      type: "literal",
      text: text,
      ignoreCase: ignoreCase
    };
  }

  function peg$classExpectation(parts, inverted, ignoreCase) {
    return {
      type: "class",
      parts: parts,
      inverted: inverted,
      ignoreCase: ignoreCase
    };
  }

  function peg$anyExpectation() {
    return {
      type: "any"
    };
  }

  function peg$endExpectation() {
    return {
      type: "end"
    };
  }

  function peg$otherExpectation(description) {
    return {
      type: "other",
      description: description
    };
  }

  function peg$computePosDetails(pos) {
    var details = peg$posDetailsCache[pos],
        p;

    if (details) {
      return details;
    } else {
      p = pos - 1;

      while (!peg$posDetailsCache[p]) {
        p--;
      }

      details = peg$posDetailsCache[p];
      details = {
        line: details.line,
        column: details.column
      };

      while (p < pos) {
        if (input.charCodeAt(p) === 10) {
          details.line++;
          details.column = 1;
        } else {
          details.column++;
        }

        p++;
      }

      peg$posDetailsCache[pos] = details;
      return details;
    }
  }

  function peg$computeLocation(startPos, endPos) {
    var startPosDetails = peg$computePosDetails(startPos),
        endPosDetails = peg$computePosDetails(endPos);
    return {
      start: {
        offset: startPos,
        line: startPosDetails.line,
        column: startPosDetails.column
      },
      end: {
        offset: endPos,
        line: endPosDetails.line,
        column: endPosDetails.column
      }
    };
  }

  function peg$fail(expected) {
    if (peg$currPos < peg$maxFailPos) {
      return;
    }

    if (peg$currPos > peg$maxFailPos) {
      peg$maxFailPos = peg$currPos;
      peg$maxFailExpected = [];
    }

    peg$maxFailExpected.push(expected);
  }

  function peg$buildStructuredError(expected, found, location) {
    return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
  }

  function peg$decode(s) {
    var bc = new Array(s.length),
        i;

    for (i = 0; i < s.length; i++) {
      bc[i] = s.charCodeAt(i) - 32;
    }

    return bc;
  }

  function peg$parseRule(index) {
    var bc = peg$bytecode[index],
        ip = 0,
        ips = [],
        end = bc.length,
        ends = [],
        stack = [],
        params,
        i;

    while (true) {
      while (ip < end) {
        switch (bc[ip]) {
          case 0:
            stack.push(peg$consts[bc[ip + 1]]);
            ip += 2;
            break;

          case 1:
            stack.push(void 0);
            ip++;
            break;

          case 2:
            stack.push(null);
            ip++;
            break;

          case 3:
            stack.push(peg$FAILED);
            ip++;
            break;

          case 4:
            stack.push([]);
            ip++;
            break;

          case 5:
            stack.push(peg$currPos);
            ip++;
            break;

          case 6:
            stack.pop();
            ip++;
            break;

          case 7:
            peg$currPos = stack.pop();
            ip++;
            break;

          case 8:
            stack.length -= bc[ip + 1];
            ip += 2;
            break;

          case 9:
            stack.splice(-2, 1);
            ip++;
            break;

          case 10:
            stack[stack.length - 2].push(stack.pop());
            ip++;
            break;

          case 11:
            stack.push(stack.splice(stack.length - bc[ip + 1], bc[ip + 1]));
            ip += 2;
            break;

          case 12:
            stack.push(input.substring(stack.pop(), peg$currPos));
            ip++;
            break;

          case 13:
            ends.push(end);
            ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

            if (stack[stack.length - 1]) {
              end = ip + 3 + bc[ip + 1];
              ip += 3;
            } else {
              end = ip + 3 + bc[ip + 1] + bc[ip + 2];
              ip += 3 + bc[ip + 1];
            }

            break;

          case 14:
            ends.push(end);
            ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

            if (stack[stack.length - 1] === peg$FAILED) {
              end = ip + 3 + bc[ip + 1];
              ip += 3;
            } else {
              end = ip + 3 + bc[ip + 1] + bc[ip + 2];
              ip += 3 + bc[ip + 1];
            }

            break;

          case 15:
            ends.push(end);
            ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

            if (stack[stack.length - 1] !== peg$FAILED) {
              end = ip + 3 + bc[ip + 1];
              ip += 3;
            } else {
              end = ip + 3 + bc[ip + 1] + bc[ip + 2];
              ip += 3 + bc[ip + 1];
            }

            break;

          case 16:
            if (stack[stack.length - 1] !== peg$FAILED) {
              ends.push(end);
              ips.push(ip);
              end = ip + 2 + bc[ip + 1];
              ip += 2;
            } else {
              ip += 2 + bc[ip + 1];
            }

            break;

          case 17:
            ends.push(end);
            ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);

            if (input.length > peg$currPos) {
              end = ip + 3 + bc[ip + 1];
              ip += 3;
            } else {
              end = ip + 3 + bc[ip + 1] + bc[ip + 2];
              ip += 3 + bc[ip + 1];
            }

            break;

          case 18:
            ends.push(end);
            ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

            if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length) === peg$consts[bc[ip + 1]]) {
              end = ip + 4 + bc[ip + 2];
              ip += 4;
            } else {
              end = ip + 4 + bc[ip + 2] + bc[ip + 3];
              ip += 4 + bc[ip + 2];
            }

            break;

          case 19:
            ends.push(end);
            ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

            if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length).toLowerCase() === peg$consts[bc[ip + 1]]) {
              end = ip + 4 + bc[ip + 2];
              ip += 4;
            } else {
              end = ip + 4 + bc[ip + 2] + bc[ip + 3];
              ip += 4 + bc[ip + 2];
            }

            break;

          case 20:
            ends.push(end);
            ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);

            if (peg$consts[bc[ip + 1]].test(input.charAt(peg$currPos))) {
              end = ip + 4 + bc[ip + 2];
              ip += 4;
            } else {
              end = ip + 4 + bc[ip + 2] + bc[ip + 3];
              ip += 4 + bc[ip + 2];
            }

            break;

          case 21:
            stack.push(input.substr(peg$currPos, bc[ip + 1]));
            peg$currPos += bc[ip + 1];
            ip += 2;
            break;

          case 22:
            stack.push(peg$consts[bc[ip + 1]]);
            peg$currPos += peg$consts[bc[ip + 1]].length;
            ip += 2;
            break;

          case 23:
            stack.push(peg$FAILED);

            if (peg$silentFails === 0) {
              peg$fail(peg$consts[bc[ip + 1]]);
            }

            ip += 2;
            break;

          case 24:
            peg$savedPos = stack[stack.length - 1 - bc[ip + 1]];
            ip += 2;
            break;

          case 25:
            peg$savedPos = peg$currPos;
            ip++;
            break;

          case 26:
            params = bc.slice(ip + 4, ip + 4 + bc[ip + 3]);

            for (i = 0; i < bc[ip + 3]; i++) {
              params[i] = stack[stack.length - 1 - params[i]];
            }

            stack.splice(stack.length - bc[ip + 2], bc[ip + 2], peg$consts[bc[ip + 1]].apply(null, params));
            ip += 4 + bc[ip + 3];
            break;

          case 27:
            stack.push(peg$parseRule(bc[ip + 1]));
            ip += 2;
            break;

          case 28:
            peg$silentFails++;
            ip++;
            break;

          case 29:
            peg$silentFails--;
            ip++;
            break;

          default:
            throw new Error("Invalid opcode: " + bc[ip] + ".");
        }
      }

      if (ends.length > 0) {
        end = ends.pop();
        ip = ips.pop();
      } else {
        break;
      }
    }

    return stack[0];
  }

  peg$result = peg$parseRule(peg$startRuleIndex);

  if (peg$result !== peg$FAILED && peg$currPos === input.length) {
    return peg$result;
  } else {
    if (peg$result !== peg$FAILED && peg$currPos < input.length) {
      peg$fail(peg$endExpectation());
    }

    throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
  }
}

var grammar = {
  SyntaxError: peg$SyntaxError,
  parse: peg$parse
};
var grammar_1 = grammar.parse;

var strength$1 = {
  required: kiwi.Strength.required,
  strong: kiwi.Strength.strong,
  medium: kiwi.Strength.medium,
  weak: kiwi.Strength.weak // generate a kiwi solver from a series of linear equations

};
function compile(input) {
  var solver = new kiwi.Solver();
  var vars = {};
  var exprs = {};

  var _c = function _c(expr) {
    if (exprs[expr]) return exprs[expr];

    switch (expr.type) {
      case 'Inequality':
        var op = expr.operator == '<=' ? kiwi.Operator.Le : kiwi.Operator.Ge;
        var i = new kiwi.Constraint(_c(expr.left), op, _c(expr.right), strength$1[expr.strength.toLowerCase()]);
        solver.addConstraint(i);
        return i;

      case 'Equality':
        var i = new kiwi.Constraint(_c(expr.left), kiwi.Operator.Eq, _c(expr.right), strength$1[expr.strength.toLowerCase()]);
        solver.addConstraint(i);
        return i;

      case 'MultiplicativeExpression':
        if (expr.operator == '*') {
          // the right hand side must be a number. determine which one this is
          var lhs = expr.right.type === 'NumericLiteral' ? _c(expr.left) : _c(expr.right);
          var rhs = expr.right.type === 'NumericLiteral' ? _c(expr.right) : _c(expr.left);
          return lhs.multiply(rhs);
        } else {
          return _c(expr.left).divide(_c(expr.right));
        }

      case 'AdditiveExpression':
        if (expr.operator == '+') return _c(expr.left).plus(_c(expr.right));else return _c(expr.left).minus(_c(expr.right));

      case 'NumericLiteral':
        return expr.value;
      //new kiwi.Expression(expr.value)

      case 'EditableVariable':
        if (!vars[expr.name]) {
          vars[expr.name] = new kiwi.Variable(expr.name);
          solver.addEditVariable(vars[expr.name], strength$1[expr.strength.toLowerCase()]);
        }

        return vars[expr.name];

      case 'Variable':
        if (!vars[expr.name]) vars[expr.name] = new kiwi.Variable(expr.name);
        return vars[expr.name];

      case 'UnaryExpression':
        console.log('UnaryExpression...WTF?');
        break;
    }
  };

  var expressions = grammar_1(input);
  expressions.map(_c);
  return {
    solver: solver,
    vars: vars
  };
}

function constraints(constraintString) {
  var _compile = compile(constraintString),
      solver = _compile.solver,
      vars = _compile.vars;

  var getValues = function getValues() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        roundToInt = _ref.roundToInt;

    var result = {};

    for (var variableName in vars) {
      result[variableName] = roundToInt === true ? Math.round(vars[variableName].value()) : vars[variableName].value();
    }

    return result;
  };

  var suggestValue = function suggestValue(variableName, value) {
    var v = vars[variableName];
    if (v) solver.suggestValue(v, value);
  };

  return {
    getValues: getValues,
    suggestValue: suggestValue,
    updateVariables: function updateVariables() {
      return solver.updateVariables();
    }
  };
}

module.exports = constraints;
